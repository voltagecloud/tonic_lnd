#![allow(clippy::large_enum_variant)]
#![allow(clippy::doc_lazy_continuation)]
/// This is part of public interface so it's re-exported.
pub extern crate tonic;

mod error;

use error::{ConnectError, InternalConnectError};
use std::path::{Path, PathBuf};
use std::str::FromStr;
use tonic::service::interceptor::InterceptedService;
use tonic::transport::{Certificate, ClientTlsConfig, Endpoint, Uri};

type Service = InterceptedService<tonic::transport::Channel, MacaroonInterceptor>;

/// Convenience type alias for lightning client.
#[cfg(feature = "lightningrpc")]
pub type LightningClient = lnrpc::lightning_client::LightningClient<Service>;

/// Convenience type alias for wallet client.
#[cfg(feature = "walletrpc")]
pub type WalletKitClient = walletrpc::wallet_kit_client::WalletKitClient<Service>;

/// Convenience type alias for peers service client.
#[cfg(feature = "peersrpc")]
pub type PeersClient = peersrpc::peers_client::PeersClient<Service>;

/// Convenience type alias for versioner service client.
#[cfg(feature = "versionrpc")]
pub type VersionerClient = verrpc::versioner_client::VersionerClient<Service>;

// Convenience type alias for signer client.
#[cfg(feature = "signrpc")]
pub type SignerClient = signrpc::signer_client::SignerClient<Service>;

/// Convenience type alias for router client.
#[cfg(feature = "routerrpc")]
pub type RouterClient = routerrpc::router_client::RouterClient<Service>;

/// Convenience type alias for invoices client.
#[cfg(feature = "invoicesrpc")]
pub type InvoicesClient = invoicesrpc::invoices_client::InvoicesClient<Service>;

/// The client returned by `connect` function
///
/// This is a convenience type which you most likely want to use instead of raw client.
#[derive(Clone)]
pub struct Client {
    #[cfg(feature = "lightningrpc")]
    lightning: LightningClient,
    #[cfg(feature = "walletrpc")]
    wallet: WalletKitClient,
    #[cfg(feature = "signrpc")]
    signer: SignerClient,
    #[cfg(feature = "peersrpc")]
    peers: PeersClient,
    #[cfg(feature = "versionrpc")]
    version: VersionerClient,
    #[cfg(feature = "routerrpc")]
    router: RouterClient,
    #[cfg(feature = "invoicesrpc")]
    invoices: InvoicesClient,
}

impl Client {
    /// Returns the lightning client.
    #[cfg(feature = "lightningrpc")]
    pub fn lightning(&mut self) -> &mut LightningClient {
        &mut self.lightning
    }

    /// Returns a read-only lightning client.
    #[cfg(feature = "lightningrpc")]
    pub fn lightning_read_only(self) -> LightningClient {
        self.lightning
    }

    /// Returns the wallet client.
    #[cfg(feature = "walletrpc")]
    pub fn wallet(&mut self) -> &mut WalletKitClient {
        &mut self.wallet
    }

    /// Returns a read-only wallet client.
    #[cfg(feature = "walletrpc")]
    pub fn wallet_read_only(self) -> WalletKitClient {
        self.wallet
    }

    /// Returns the signer client.
    #[cfg(feature = "signrpc")]
    pub fn signer(&mut self) -> &mut SignerClient {
        &mut self.signer
    }

    /// Returns a read-only signer client.
    #[cfg(feature = "signrpc")]
    pub fn signer_read_only(self) -> SignerClient {
        self.signer
    }

    /// Returns the versioner client.
    #[cfg(feature = "versionrpc")]
    pub fn versioner(&mut self) -> &mut VersionerClient {
        &mut self.version
    }

    /// Returns a read-only versioner client.
    #[cfg(feature = "versionrpc")]
    pub fn versioner_read_only(self) -> VersionerClient {
        self.version
    }

    /// Returns the peers client.
    #[cfg(feature = "peersrpc")]
    pub fn peers(&mut self) -> &mut PeersClient {
        &mut self.peers
    }

    /// Returns a read-only peers client.
    #[cfg(feature = "peersrpc")]
    pub fn peers_read_only(self) -> PeersClient {
        self.peers
    }

    /// Returns the router client.
    #[cfg(feature = "routerrpc")]
    pub fn router(&mut self) -> &mut RouterClient {
        &mut self.router
    }

    /// Returns a read-only router client.
    #[cfg(feature = "routerrpc")]
    pub fn router_read_only(self) -> RouterClient {
        self.router
    }

    /// Returns the invoices client.
    #[cfg(feature = "invoicesrpc")]
    pub fn invoices(&mut self) -> &mut InvoicesClient {
        &mut self.invoices
    }

    /// Returns a read-only invoices client.
    #[cfg(feature = "invoicesrpc")]
    pub fn invoices_read_only(self) -> InvoicesClient {
        self.invoices
    }
}

/// [`tonic::Status`] is re-exported as `Error` for convenience.
pub type Error = tonic::Status;

/// Messages and other types generated by `tonic`/`prost`
///
/// This is the go-to module you will need to look in to find documentation on various message
/// types. However it may be better to start from methods on the [`LightningClient`](lnrpc::lightning_client::LightningClient) type.
#[cfg(feature = "lightningrpc")]
pub mod lnrpc {
    tonic::include_proto!("lnrpc");
}

#[cfg(feature = "walletrpc")]
pub mod walletrpc {
    tonic::include_proto!("walletrpc");
}

#[cfg(feature = "signrpc")]
pub mod signrpc {
    tonic::include_proto!("signrpc");
}

#[cfg(feature = "peersrpc")]
pub mod peersrpc {
    tonic::include_proto!("peersrpc");
}

#[cfg(feature = "routerrpc")]
pub mod routerrpc {
    tonic::include_proto!("routerrpc");
}

#[cfg(feature = "versionrpc")]
pub mod verrpc {
    tonic::include_proto!("verrpc");
}

#[cfg(feature = "invoicesrpc")]
pub mod invoicesrpc {
    tonic::include_proto!("invoicesrpc");
}

/// Supplies requests with macaroon
#[derive(Clone)]
pub struct MacaroonInterceptor {
    macaroon: String,
}

impl tonic::service::Interceptor for MacaroonInterceptor {
    fn call(&mut self, mut request: tonic::Request<()>) -> Result<tonic::Request<()>, Error> {
        request.metadata_mut().insert(
            "macaroon",
            tonic::metadata::MetadataValue::from_str(&self.macaroon)
                .expect("hex produced non-ascii"),
        );
        Ok(request)
    }
}

async fn load_file(
    path: impl AsRef<Path> + Into<PathBuf>,
) -> Result<Vec<u8>, InternalConnectError> {
    tokio::fs::read(&path)
        .await
        .map_err(|error| InternalConnectError::ReadFile {
            file: path.into(),
            error,
        })
}

async fn load_macaroon(
    path: impl AsRef<Path> + Into<PathBuf>,
) -> Result<String, InternalConnectError> {
    let macaroon = load_file(path).await?;

    Ok(hex::encode(macaroon))
}

/// Connects to LND using given address and credentials
///
/// This function does all required processing of the cert file and macaroon file, so that you
/// don't have to. The address must begin with "https://", though.
///
/// This is considered the recommended way to connect to LND. An alternative function to use
/// already-read certificate or macaroon data is currently **not** provided to discourage such use.
/// LND occasionally changes that data which would lead to errors and in turn in worse application.
///
/// If you have a motivating use case for use of direct data feel free to open an issue and
/// explain.
pub async fn connect<CP, MP>(
    address: String,
    cert_file: CP,
    macaroon_file: MP,
) -> Result<Client, ConnectError>
where
    CP: AsRef<Path> + Into<PathBuf> + std::fmt::Debug,
    MP: AsRef<Path> + Into<PathBuf> + std::fmt::Debug,
{
    let contents = load_file(cert_file).await?;
    let cert = Certificate::from_pem(&contents);

    let macaroon = load_macaroon(macaroon_file).await?;

    do_connect(address, Some(cert), macaroon).await
}

/// connect_from_memory connects to LND using in-memory cert and macaroon instead of from file paths.
/// `cert`` is a PEM encoded string
/// `macaroon`` is a hex-encoded string
/// These credentials can get out of date! Make sure you are pulling fresh credentials when using this function.
pub async fn connect_from_memory(
    address: impl ToString,
    cert_pem: impl ToString,
    macaroon: impl ToString,
) -> Result<Client, ConnectError> {
    let cert_pem = cert_pem.to_string();
    let cert = Certificate::from_pem(cert_pem.as_bytes());

    let address = address.to_string();
    let macaroon = macaroon.to_string();

    do_connect(address, Some(cert), macaroon).await
}

pub async fn connect_from_memory_with_system_certs(
    address: impl ToString,
    macaroon: impl ToString,
) -> Result<Client, ConnectError> {
    let address = address.to_string();
    let macaroon = macaroon.to_string();

    do_connect(address, None, macaroon).await
}

async fn do_connect(
    address: String,
    certs: Option<Certificate>,
    macaroon: String,
) -> Result<Client, ConnectError> {
    let mut endpoint =
        Endpoint::from_shared(address.clone()).map_err(InternalConnectError::Endpoint)?;

    if let Some(cert) = certs {
        let tls_config = ClientTlsConfig::new()
            .ca_certificate(cert)
            .with_enabled_roots();
        endpoint = endpoint
            .tls_config(tls_config)
            .map_err(InternalConnectError::Endpoint)?;
    }

    let channel = endpoint
        .connect()
        .await
        .map_err(InternalConnectError::Endpoint)?;
    let channel = InterceptedService::new(channel, MacaroonInterceptor { macaroon });

    let uri =
        Uri::from_str(address.as_str()).map_err(|error| InternalConnectError::InvalidAddress {
            address,
            error: Box::new(error),
        })?;

    let client = Client {
        #[cfg(feature = "lightningrpc")]
        lightning: lnrpc::lightning_client::LightningClient::with_origin(
            channel.clone(),
            uri.clone(),
        ),
        #[cfg(feature = "walletrpc")]
        wallet: walletrpc::wallet_kit_client::WalletKitClient::with_origin(
            channel.clone(),
            uri.clone(),
        ),
        #[cfg(feature = "peersrpc")]
        peers: peersrpc::peers_client::PeersClient::with_origin(channel.clone(), uri.clone()),
        #[cfg(feature = "signrpc")]
        signer: signrpc::signer_client::SignerClient::with_origin(channel.clone(), uri.clone()),
        #[cfg(feature = "versionrpc")]
        version: verrpc::versioner_client::VersionerClient::with_origin(
            channel.clone(),
            uri.clone(),
        ),
        #[cfg(feature = "routerrpc")]
        router: routerrpc::router_client::RouterClient::with_origin(channel.clone(), uri.clone()),
        #[cfg(feature = "invoicesrpc")]
        invoices: invoicesrpc::invoices_client::InvoicesClient::with_origin(
            channel.clone(),
            uri.clone(),
        ),
    };

    Ok(client)
}
